[
  {
    "id": 1,
    "question": "Case ID 1, 2, 9번 환자들의 심박수(HR) 최댓값을 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_max_hr(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n        if vals is None or len(vals) == 0: return None\n        return float(np.nanmax(vals[:, 0]))\n    except: return None\n\ndef get_hr_max_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_max_hr, [1, 2, 9]))\n    return results",
    "answer": "[139.0, 177.0, 141.0]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 2,
    "question": "Case ID 1, 2, 9번 환자들의 심박수(HR) 최솟값을 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_min_hr(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n        if vals is None or len(vals) == 0: return None\n        return float(np.nanmin(vals[:, 0]))\n    except: return None\n\ndef get_hr_min_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_min_hr, [1, 2, 9]))\n    return results",
    "answer": "[57.0, 54.0, 52.0]",
    "detail_score": 0.7,
    "format": "list"
  },
  {
    "id": 3,
    "question": "Case ID 1, 2, 9번 환자들의 심박수(HR) 중간값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_median_hr(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n        if vals is None or len(vals) == 0: return None\n        val = np.nanmedian(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_hr_median_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_median_hr, [1, 2, 9]))\n    return results",
    "answer": "[74.0, 80.0, 69.0]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 4,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_MBP' 트랙의 평균값을 각각 구해주세요. 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_mean_abp(case_id):\n    try:\n        # ABP Mean = Solar8000/ART_MBP 트랙 사용\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_MBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        val = np.nanmean(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_abp_mean_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_mean_abp, [1, 2, 9]))\n    return results",
    "answer": "[81.86, null, null]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 5,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_SBP' 트랙의 최댓값을 각각 구해주세요. (주의: 해당 트랙이 없으면 NIBP 등 다른 데이터를 찾지 말고 바로 None을 반환하세요.) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_max_abp(case_id):\n    try:\n        # ABP Max = Solar8000/ART_SBP (수축기) 트랙 사용\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_SBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        val = np.nanmax(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_abp_max_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_max_abp, [1, 2, 9]))\n    return results",
    "answer": "[322.0, null, null]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 6,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_DBP' 트랙의 최솟값(0이하 노이즈 제거)을 각각 구해주세요. 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_min_abp_filtered(case_id):\n    try:\n        # ABP Min = Solar8000/ART_DBP (이완기) 트랙 사용\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_DBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        data = vals[:, 0]\n        # 0보다 큰 값만 추출 (0이하 노이즈 제거)\n        valid_data = data[data > 0]\n        \n        if len(valid_data) > 0:\n            return round(float(np.min(valid_data)), 2)\n        else:\n            return None\n    except: return None\n\ndef get_abp_min_filtered_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_min_abp_filtered, [1, 2, 9]))\n    return results",
    "answer": "[1.0, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 7,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_MBP' 트랙의 중간값을 각각 구해주세요. 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_median_abp(case_id):\n    try:\n        # ABP의 중심 경향(Median) = Solar8000/ART_MBP 사용\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_MBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        # 결측치 제외 중간값 계산\n        val = np.nanmedian(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_abp_median_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_median_abp, [1, 2, 9]))\n    return results",
    "answer": "[80.0, null, null]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 8,
    "question": "Case ID 1, 2, 9번 환자들의 SpO2 평균값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_mean_spo2(case_id):\n    try:\n        # SpO2 트랙 로드 (Solar8000/PLETH_SPO2)\n        vals = vitaldb.load_case(case_id, ['Solar8000/PLETH_SPO2'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        # NaN 제외하고 평균 계산\n        val = np.nanmean(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_spo2_mean_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_mean_spo2, [1, 2, 9]))\n    return results",
    "answer": "[98.73, 99.94, 99.61]",
    "detail_score": 0.8,
    "format": "list"
  },
  {
    "id": 9,
    "question": "Case ID 1, 2, 9번 환자들의 SpO2 최솟값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_min_spo2(case_id):\n    try:\n        # SpO2 트랙 로드\n        vals = vitaldb.load_case(case_id, ['Solar8000/PLETH_SPO2'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        # 필터링 없이 순수 최솟값 계산 (np.nanmin)\n        val = np.nanmin(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_spo2_min_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_min_spo2, [1, 2, 9]))\n    return results",
    "answer": "[77.0, 85.0, 82.0]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 10,
    "question": "Case ID 1, 2, 9번 환자들의 SpO2 중간값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_median_spo2(case_id):\n    try:\n        # SpO2 트랙 로드\n        vals = vitaldb.load_case(case_id, ['Solar8000/PLETH_SPO2'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        # 중간값(Median) 계산 - 이상치에 강함\n        val = np.nanmedian(vals[:, 0])\n        return round(float(val), 2)\n    except: return None\n\ndef get_spo2_median_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_median_spo2, [1, 2, 9]))\n    return results",
    "answer": "[99.0, 100.0, 100.0]",
    "detail_score": 0.9,
    "format": "list"
  },
  {
    "id": 11,
    "question": "Case ID 1, 2, 9번 환자들의 BIS 평균값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_mean_bis(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['BIS/BIS'], 1)\n        if vals is None or len(vals) == 0: return None\n        bis_data = vals[:, 0]\n        # 0을 포함하여 평균 계산 (NaN만 제거)\n        valid_bis = bis_data[~np.isnan(bis_data)]\n        if len(valid_bis) == 0: return None\n        return round(float(np.mean(valid_bis)), 2)\n    except: return None\n\ndef get_bis_mean_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_mean_bis, [1, 2, 9]))\n    return results",
    "answer": "[44.61, 47.98, 46.31]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 12,
    "question": "Case ID 1, 2, 9번 환자들의 BIS 최솟값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_min_bis(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['BIS/BIS'], 1)\n        if vals is None or len(vals) == 0: return None\n        bis_data = vals[:, 0]\n        # 0을 포함하여 최솟값 계산\n        val = np.nanmin(bis_data)\n        if np.isnan(val): return None\n        return round(float(val), 2)\n    except: return None\n\ndef get_bis_min_batch_fast(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_min_bis, [1, 2, 9]))\n    return results",
    "answer": "[0.0, 0.0, 0.0]",
    "detail_score": 0.7,
    "format": "list"
  },
  {
    "id": 13,
    "question": "Case ID 1, 2, 9번 환자들의 BIS 중간값을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_median_bis(case_id):\n    try:\n        vals = vitaldb.load_case(case_id, ['BIS/BIS'], 1)\n        if vals is None or len(vals) == 0: return None\n        # 0을 포함하여 중간값 계산\n        val = np.nanmedian(vals[:, 0])\n        if np.isnan(val): return None\n        return round(float(val), 2)\n    except: return None\n\ndef get_bis_median_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_median_bis, [1, 2, 9]))\n    return results",
    "answer": "[48.0, 46.9, 48.3]",
    "detail_score": 0.8,
    "format": "list"
  },
  {
    "id": 14,
    "question": "Case ID 1, 2, 9번 환자들의 수술 시간(분 단위)을 각각 구해주세요 순서대로 리스트로 알려주세요.",
    "tool": "import pandas as pd\n\ndef get_op_duration_batch(start_id=1, end_id=100):\n    df_cases = pd.read_csv('https://api.vitaldb.net/cases')\n    df_selected = df_cases[df_cases['caseid'].isin([1, 2, 9])].copy()\n    # 수술 종료(opend) - 수술 시작(opstart)을 60으로 나누어 분 단위 계산\n    df_selected['duration_min'] = (df_selected['opend'] - df_selected['opstart']) / 60\n    return [round(d, 1) if pd.notnull(d) else None for d in df_selected['duration_min']]",
    "answer": "[145.0, 215.0, 40.0]",
    "detail_score": 0.95,
    "format": "list"
  },
  {
    "id": 15,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_SBP' 트랙의 평균값을 구해주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_sbp_mean_filtered(case_id):\n    try:\n        # SBP = 'Solar8000/ART_SBP' 트랙\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_SBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        sbp_data = vals[:, 0]\n        # 0 이하 노이즈 및 NaN 제외\n        valid_sbp = sbp_data[(sbp_data > 0) & (~np.isnan(sbp_data))]\n        \n        if len(valid_sbp) == 0: return None\n        return round(float(np.mean(valid_sbp)), 2)\n    except: return None\n\ndef get_sbp_mean_batch_filtered(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_sbp_mean_filtered, [1, 2, 9]))\n    return results",
    "answer": "[127.67, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 16,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_SBP' 트랙의 최댓값을 각각 구해주세요. 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_sbp_max(case_id):\n    try:\n        # SBP = 'Solar8000/ART_SBP' 트랙\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_SBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        sbp_data = vals[:, 0]\n        # 모든 값이 NaN인 경우 제외\n        if np.all(np.isnan(sbp_data)): return None\n            \n        # 최댓값은 노이즈(0)보다 크므로 별도 필터 없이 nanmax 사용\n        return round(float(np.nanmax(sbp_data)), 2)\n    except: return None\n\ndef get_sbp_max_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_sbp_max, [1, 2, 9]))\n    return results",
    "answer": "[322.0, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 17,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_SBP' 트랙의 최솟값을 각각 구해주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_sbp_min_filtered(case_id):\n    try:\n        # SBP = 'Solar8000/ART_SBP' 트랙\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_SBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        sbp_data = vals[:, 0]\n        # 0 이하 및 NaN 제외\n        valid_sbp = sbp_data[(sbp_data > 0) & (~np.isnan(sbp_data))]\n        \n        if len(valid_sbp) == 0: return None\n        return round(float(np.min(valid_sbp)), 2)\n    except: return None\n\ndef get_sbp_min_batch_filtered(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_sbp_min_filtered, [1, 2, 9]))\n    return results",
    "answer": "[1.0, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 18,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_SBP' 트랙의 중간값을 각각 구해주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_sbp_median_filtered(case_id):\n    try:\n        # SBP = 'Solar8000/ART_SBP' 트랙\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_SBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        sbp_data = vals[:, 0]\n        # 0 이하 및 NaN 제외\n        valid_sbp = sbp_data[(sbp_data > 0) & (~np.isnan(sbp_data))]\n        \n        if len(valid_sbp) == 0: return None\n        return round(float(np.median(valid_sbp)), 2)\n    except: return None\n\ndef get_sbp_median_batch_filtered(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_sbp_median_filtered, [1, 2, 9]))\n    return results",
    "answer": "[122.0, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 19,
    "question": "Case ID 1, 2, 9번 환자들의 'Solar8000/ART_DBP' 트랙의 평균값, 최댓값, 최솟값, 중간값을 각각 구해주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것) 각 환자의 결과는 딕셔너리({'mean': ..., 'max': ..., 'min': ..., 'median': ...}) 형태로 반환하고, 해당 트랙 데이터가 없으면 딕셔너리 대신 None을 반환하세요. 전체 결과는 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_dbp_stats(case_id):\n    try:\n        # DBP = 'Solar8000/ART_DBP'\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_DBP'], 1)\n        if vals is None or len(vals) == 0: \n            return None\n        \n        dbp_data = vals[:, 0]\n        # 0 이하 및 NaN 제외\n        valid_dbp = dbp_data[(dbp_data > 0) & (~np.isnan(dbp_data))]\n        \n        if len(valid_dbp) == 0: \n            return None\n            \n        return {\n            \"mean\": round(float(np.mean(valid_dbp)), 2),\n            \"max\": round(float(np.max(valid_dbp)), 2),\n            \"min\": round(float(np.min(valid_dbp)), 2),\n            \"median\": round(float(np.median(valid_dbp)), 2)\n        }\n    except: \n        return None\n\ndef get_dbp_stats_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_dbp_stats, [1, 2, 9]))\n    return results",
    "answer": "[{'mean': 59.28, 'max': 312.0, 'min': 1.0, 'median': 57.0}, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 20,
    "question": "Case ID 1, 2, 9번 환자의 'Solar8000/ETCO2' 트랙의 평균값은 순서대로 리스트로 알려주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것)",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_etco2_mean(case_id):\n    try:\n        # EtCO2 = 'Solar8000/ETCO2'\n        vals = vitaldb.load_case(case_id, ['Solar8000/ETCO2'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        etco2_data = vals[:, 0]\n        # 0 이하 및 NaN 제외\n        valid_etco2 = etco2_data[(etco2_data > 0) & (~np.isnan(etco2_data))]\n        \n        if len(valid_etco2) == 0: return None\n        return round(float(np.mean(valid_etco2)), 2)\n    except: return None\n\ndef get_etco2_mean_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_etco2_mean, [1, 2, 9]))\n    print(\"완료\")\n    return results",
    "answer": "[32.24, 34.01, 35.51]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 21,
    "question": "Case ID 1, 2, 9번 환자의 'Solar8000/ETCO2' 트랙의 최댓값, 최솟값, 중간값은 순서대로 리스트로 알려주세요. (반드시 0 이하 값은 노이즈로 간주하여 제외할 것) 각 환자의 결과는 딕셔너리({'max': ..., 'min': ..., 'median': ...}) 형태로 반환해주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_etco2_stats(case_id):\n    try:\n        # EtCO2 = 'Solar8000/ETCO2'\n        vals = vitaldb.load_case(case_id, ['Solar8000/ETCO2'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        etco2_data = vals[:, 0]\n        # 통상적인 분석을 위해 0 이하 노이즈 제거 (Min 값이 0이 되지 않도록)\n        valid_etco2 = etco2_data[(etco2_data > 0) & (~np.isnan(etco2_data))]\n        \n        if len(valid_etco2) == 0: return None\n        \n        return {\n            \"max\": round(float(np.max(valid_etco2)), 2),\n            \"min\": round(float(np.min(valid_etco2)), 2),\n            \"median\": round(float(np.median(valid_etco2)), 2)\n        }\n    except: return None\n\ndef get_etco2_stats_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_etco2_stats, [1, 2, 9]))\n    return results",
    "answer": "[{'max': 40.0, 'min': 26.0, 'median': 32.0}, {'max': 39.0, 'min': 15.0, 'median': 34.0}, {'max': 41.0, 'min': 1.0, 'median': 35.0}]",
    "detail_score": 0.75,
    "format": "list"
  },
  {
    "id": 22,
    "question": "Case ID 1, 2, 9 환자의 HRV(심박변이도)를 구해주세요. 1초 간격의 심박수(HR) 데이터를 이용하여 RR 간격을 추정하고, 이를 통해 SDNN(Standard Deviation of NN intervals) 값을 계산하세요. (0 이하 및 NaN 제외) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_hrv_sdnn(case_id):\n    try:\n        # HRV usually requires ECG analysis (R-R intervals). \n        # For a simple API check without downloading waveforms, we approximate using the HR track.\n        # We calculate SDNN (Standard Deviation of NN intervals) from the 1-second HR data.\n        # This is an approximation.\n        vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        hr_data = vals[:, 0]\n        # Filter valid HR (excluding 0 and NaN)\n        valid_hr = hr_data[(hr_data > 0) & (~np.isnan(hr_data))]\n        \n        if len(valid_hr) < 2: return None\n        \n        # Convert BPM to RR intervals (ms)\n        rr_intervals = 60000 / valid_hr\n        \n        # Calculate SDNN (Standard Deviation of RR intervals)\n        sdnn = np.std(rr_intervals)\n        \n        return round(float(sdnn), 2)\n    except: return None\n\ndef get_hrv_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_hrv_sdnn, [1, 2, 9]))\n    return results",
    "answer": "[130.78, 95.78, 151.36]",
    "detail_score": 0.6,
    "format": "list"
  },
  {
    "id": 23,
    "question": "Case ID 1, 2, 9번 환자의 'Solar8000/ART_DBP' 트랙 값이 90mmHg 이상인 구간이 몇 분간 지속되었는지 알려줘 (주의: 해당 트랙이 없으면 0분이 아니라 None을 반환하세요. 0 이하 값은 노이즈로 제외하고 계산) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_dbp_over_90_duration(case_id):\n    try:\n        # 지속 시간을 계산하려면 연속 데이터인 'Solar8000/ART_DBP' (1초 간격)가 적합\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_DBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        dbp_data = vals[:, 0]\n        # NaN 제외\n        valid_dbp = dbp_data[~np.isnan(dbp_data)]\n        \n        if len(valid_dbp) == 0: return 0.0\n        \n        # 90 이상인 데이터 포인트 개수 (1초 간격이므로 개수 = 초)\n        count_seconds = np.sum(valid_dbp >= 90)\n        \n        # 분(minute) 단위로 변환\n        duration_min = round(count_seconds / 60.0, 2)\n        \n        return duration_min\n    except: return None\n\ndef get_dbp_duration_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_dbp_over_90_duration, [1, 2, 9]))\n    return results",
    "answer": "[4.0, null, null]",
    "detail_score": 0.85,
    "format": "list"
  },
  {
    "id": 24,
    "question": "Case ID 1, 2, 9번 환자의 'Solar8000/ART_DBP' 트랙 값이 50mmHg 이하인 구간이 몇 분간 지속되었는지 알려줘 (주의: 해당 트랙이 없으면 0분이 아니라 None을 반환하세요. 반드시 0 이하 값은 노이즈로 간주하여 제외하고, 0초과 50이하인 경우만 계산) 순서대로 리스트로 알려주세요.",
    "tool": "import vitaldb\nimport numpy as np\nimport concurrent.futures\n\ndef fetch_dbp_under_50_duration(case_id):\n    try:\n        # Load DBP track\n        vals = vitaldb.load_case(case_id, ['Solar8000/ART_DBP'], 1)\n        if vals is None or len(vals) == 0: return None\n        \n        dbp_data = vals[:, 0]\n        # 중요: 0보다 크고 50 이하인 값만 필터링 (0은 노이즈로 간주하고 제외)\n        valid_dbp = dbp_data[(dbp_data > 0) & (~np.isnan(dbp_data))]\n        \n        if len(valid_dbp) == 0: return 0.0\n        \n        # 50 이하인 샘플 개수 (1초 간격)\n        count_seconds = np.sum(valid_dbp <= 50)\n        \n        # 분 단위 변환\n        duration_min = round(count_seconds / 60.0, 2)\n        \n        return duration_min\n    except: return None\n\ndef get_dbp_low_duration_batch(start_id=1, end_id=100):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        results = list(executor.map(fetch_dbp_under_50_duration, [1, 2, 9]))\n    return results",
    "answer": "[30.88, null, null]",
    "detail_score": 0.8,
    "format": "list"
  }
]