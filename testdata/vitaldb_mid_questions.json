[
    {
        "id": 1,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 HR 최댓값을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\ndef get_max_hr_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 최대 심박수를 반환합니다.\n    \n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n        \n    Returns:\n        float: 구간 내 최대 심박수\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 데이터 분석 중...\")\n    # 전체 데이터를 로드\n    vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n    \n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n        \n    # 인덱스가 곧 시간(초) (interval=1)\n    # 슬라이싱을 통해 구간 추출\n    target_data = vals[start_sec:end_sec, 0]\n    \n    if len(target_data) == 0:\n        return None\n        \n    if np.all(np.isnan(target_data)):\n        return None\n        \n    return np.nanmax(target_data)\n",
        "answer": "case_id=1, 90.00 BPM"
    },
    {
        "id": 2,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 HR 최솟값을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_min_hr_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 최소 심박수를 반환합니다.\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 구간 내 최소 심박수\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 데이터 분석 중...\")\n    # 전체 데이터를 로드\n    vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    # 인덱스가 곧 시간(초) (interval=1)\n    # 슬라이싱을 통해 구간 추출\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    return np.nanmin(target_data)",
        "answer": "case_id=1, 79.00 BPM"
    },
    {
        "id": 3,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 HR 중간값을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_median_hr_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 심박수 중간값을 반환합니다.\n    \n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n        \n    Returns:\n        float: 구간 내 심박수 중간값\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 데이터 분석 중...\")\n    # 전체 데이터를 로드\n    vals = vitaldb.load_case(case_id, ['Solar8000/HR'], 1)\n    \n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n        \n    # 인덱스가 곧 시간(초) (interval=1)\n    # 슬라이싱을 통해 구간 추출\n    target_data = vals[start_sec:end_sec, 0]\n    \n    if len(target_data) == 0:\n        return None\n        \n    if np.all(np.isnan(target_data)):\n        return None\n        \n    return np.nanmedian(target_data)\n",
        "answer": "case_id=1, 88.00 BPM"
    },
    {
        "id": 4,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 동맥혈압(ABP)의 평균값을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_mean_abp_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 동맥혈압(ABP) 평균값을 반환합니다.\n    (Solar8000/ART_MBP 트랙을 사용하여 평균을 계산합니다)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 구간 내 동맥혈압 평균값\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 ABP 데이터 분석 중...\")\n\n    # 'Solar8000/ART_MBP'는 평균 동맥압(Mean Arterial Pressure) 트랙입니다.\n    # 만약 파형(Waveform)의 평균을 구해야 한다면 'Solar8000/ART'나 관련 트랙을 사용해야 하지만,\n    # 일반적인 임상 데이터 분석에서는 1초 간격의 수치 데이터(MBP)의 평균을 주로 의미한다고 가정합니다.\n    track_name = 'Solar8000/ART_MBP'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    # 인덱스가 곧 시간(초) (interval=1)\n    # 슬라이싱을 통해 구간 추출\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    return np.nanmean(target_data)\n",
        "answer": "case_id=1, -8.5 mmHg"
    },
    {
        "id": 5,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 동맥혈압(ABP)의 최댓값을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_max_abp_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 돚맥혈압(ABP) 최댓값을 반환합니다.\n    (Solar8000/ART_SBP 트랙을 사용하여 최댓값(수축기 혈압)을 계산합니다)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 구간 내 동맥혈압 최댓값 (수축기 혈압 Max)\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 ABP(SBP) 데이터 분석 중...\")\n\n    # ABP의 최댓값은 일반적으로 수축기 혈압(Systolic Blood Pressure)을 의미합니다.\n    track_name = 'Solar8000/ART_SBP'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    return np.nanmax(target_data)\n",
        "answer": "case_id=1, 8.0 mmHg"
    },
    {
        "id": 6,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 동맥혈압(ABP) 최솟값(이완기 혈압)을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_min_abp_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 동맥혈압(ABP) 최솟값을 반환합니다.\n    (Solar8000/ART_DBP 트랙을 사용하여 최솟값(이완기 혈압)을 계산합니다)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 구간 내 동맥혈압 최솟값 (이완기 혈압 Min)\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 ABP(DBP) 데이터 분석 중...\")\n\n    # ABP의 최솟값은 일반적으로 이완기 혈압(Diastolic Blood Pressure)을 의미합니다.\n    track_name = 'Solar8000/ART_DBP'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    return np.nanmin(target_data)\n",
        "answer": "case_id=1, -12.0 mmHg"
    },
    {
        "id": 7,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 동맥혈압(ABP) 중간값(Median)을 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_median_abp_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안의 동맥혈압(ABP) 중간값을 반환합니다.\n    (Solar8000/ART_MBP 트랙을 사용하여 중간값을 계산합니다)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 구간 내 동맥혈압 중간값\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 ABP(MBP) 데이터 분석 중...\")\n\n    # ABP의 중간값은 평균 동맥압(Mean Arterial Pressure) 트랙의 중간값을 사용합니다.\n    track_name = 'Solar8000/ART_MBP'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    return np.nanmedian(target_data)\n",
        "answer": "case_id=1, -8.5 mmHg"
    },
    {
        "id": 8,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 산소포화도(SpO2) 평균값을 구하고 구한 평균값의 1.5배 보다 높은 구간의 총 길이를 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_high_spo2_duration_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안 산소포화도(SpO2)의 평균을 구하고,\n    해당 평균값의 1.5배보다 높은 구간의 총 길이(초)를 반환합니다.\n    (Solar8000/PLETH_SPO2 트랙 사용)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        float: 평균값의 1.5배보다 높은 구간의 총 시간 (초)\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 SpO2 데이터 분석 중...\")\n\n    # SpO2 트랙 이름 (일반적으로 'Solar8000/PLETH_SPO2' 또는 'Solar8000/SPO2')\n    track_name = 'Solar8000/PLETH_SPO2'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        # 혹시 트랙 이름이 다를 수 있으므로 예외 처리나 다른 이름 시도 로직이 있으면 좋지만,\n        # 여기서는 간단히 에러 처리\n        raise ValueError(f\"Case {case_id}를 찾을 수 없거나 SpO2 데이터를 로드할 수 없습니다.\")\n\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return 0.0\n\n    if np.all(np.isnan(target_data)):\n        return 0.0\n\n    # 평균 계산\n    mean_val = np.nanmean(target_data)\n    threshold = mean_val * 1.5\n\n    # threshold보다 큰 값들의 개수 계산 (interval=1초 이므로 개수=초)\n    # nan 비교 시 warning 발생 가능하므로 nan_to_num 또는 > 연산 시 주의\n    # np.greater는 NaN 위치에서 False 반환 (where nan is usually False in comparison)\n    # 안전하게:\n    high_spo2_indices = np.where(target_data > threshold)[0]\n    duration = len(high_spo2_indices) * 1.0 # 1초 간격\n\n    print(f\"  > SpO2 Mean: {mean_val:.2f}, Threshold(1.5x): {threshold:.2f}, Duration > Threshold: {duration}s\")\n\n    return duration\n\n",
        "answer": "case_id=1, SpO2 Mean: 96.50, Threshold(1.5x): 144.75, Duration > Threshold: 0.0s"
    },
    {
        "id": 9,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 산소포화도(SpO2) 최댓값과 최솟값을 구하고 두 값 사이 구간의 길이를 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_spo2_max_min_interval_duration(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안 산소포화도(SpO2)의 최댓값과 최솟값을 구하고,\n    두 값이 발생한 시점 사이의 시간 간격(초)을 반환합니다.\n    (Solar8000/PLETH_SPO2 트랙 사용)\n    \n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n        \n    Returns:\n        float: 최댓값과 최솟값 발생 시점 사이의 시간 간격 (초, 절대값)\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 SpO2 Max-Min 간격 분석 중...\")\n    \n    track_name = 'Solar8000/PLETH_SPO2'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n    \n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n        \n    target_data = vals[start_sec:end_sec, 0]\n    \n    if len(target_data) == 0:\n        return None\n        \n    if np.all(np.isnan(target_data)):\n        return None\n        \n    # 최댓값과 최솟값의 인덱스 찾기 (nan 무시)\n    try:\n        max_idx = np.nanargmax(target_data)\n        min_idx = np.nanargmin(target_data)\n        \n        # 인덱스 차이가 곧 시간 차이 (interval=1초)\n        diff_sec = abs(max_idx - min_idx) * 1.0\n        \n        # 실제 값도 확인차 출력\n        max_val = target_data[max_idx]\n        min_val = target_data[min_idx]\n        print(f\"  > SpO2 Max: {max_val} (@ {start_sec + max_idx}s), Min: {min_val} (@ {start_sec + min_idx}s)\")\n        print(f\"  > Time Diff: {diff_sec}s\")\n        \n        return diff_sec\n    except ValueError:\n        return None\n\n\n",
        "answer": "case_id=1, SpO2 Max: 97.0 (@ 5s), Min: 96.0 (@ 1s), Time Diff: 4.0s"
    },
    {
        "id": 10,
        "question": "이 환자의 1초부터 20초까지의 구간에서의 혈압(DBP)의 평균값, 최댓값, 최솟값, 중간값을 구하고 각 값이 몇초에 나타났는지 구해주세요.",
        "tool_code": "import vitaldb\nimport numpy as np\n\ndef get_dbp_stats_in_range(case_id, start_sec, end_sec):\n    \"\"\"\n    특정 시간 구간(초 단위) 동안 이완기 혈압(DBP)의 평균값, 최댓값, 최솟값, 중간값을 구하고\n    각 값이 나타난 시간(초, 구간 시작 기준 상대 시간)을 반환합니다.\n    (평균과 중간값은 계산된 값이므로, 실제 데이터 중 가장 가까운 값의 시간을 찾습니다)\n    (Solar8000/ART_DBP 트랙 사용)\n\n    Args:\n        case_id (int): Case ID\n        start_sec (int): 시작 시간 (초)\n        end_sec (int): 종료 시간 (초, 포함되지 않음)\n\n    Returns:\n        dict: {'mean': (val, time), 'max': (val, time), 'min': (val, time), 'median': (val, time)}\n              데이터가 없으면 None 반환\n    \"\"\"\n    print(f\"Case {case_id}의 {start_sec}초~{end_sec}초 DBP 상세 통계 분석 중...\")\n\n    track_name = 'Solar8000/ART_DBP'\n    vals = vitaldb.load_case(case_id, [track_name], 1)\n\n    if vals is None:\n        raise ValueError(f\"Case {case_id}를 찾을 수 없습니다.\")\n\n    target_data = vals[start_sec:end_sec, 0]\n\n    if len(target_data) == 0:\n        return None\n\n    if np.all(np.isnan(target_data)):\n        return None\n\n    stats = {}\n\n    # helper to find closest time\n    def find_time_for_val(val, data):\n        # np.nanargmin with abs difference\n        # NaN safe handling\n        diff = np.abs(data - val)\n        idx = np.nanargmin(diff)\n        return start_sec + idx\n\n    # Max\n    max_val = np.nanmax(target_data)\n    max_time = start_sec + np.nanargmax(target_data)\n    stats['max'] = (max_val, max_time)\n\n    # Min\n    min_val = np.nanmin(target_data)\n    min_time = start_sec + np.nanargmin(target_data)\n    stats['min'] = (min_val, min_time)\n\n    # Mean\n    mean_val = np.nanmean(target_data)\n    mean_time = find_time_for_val(mean_val, target_data)\n    stats['mean'] = (mean_val, mean_time)\n\n    # Median\n    median_val = np.nanmedian(target_data)\n    median_time = find_time_for_val(median_val, target_data)\n    stats['median'] = (median_val, median_time)\n\n    return stats\n\n\n",
        "answer": "case_id=1, 'max': (np.float64(-8.0), np.int64(1)), 'min': (np.float64(-12.0), np.int64(15)), 'mean': (np.float64(-9.1), np.int64(7)), 'median': (np.float64(-8.5), np.int64(1))"
    }
]